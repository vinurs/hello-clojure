(ns hello-clojure.datatypes.sets)



;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 集合，专门用来存放唯一值的，集合里面的值是不能重复的
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 集合也分两种：hash sorted
#{"kurt vonnegut" 20 :icicle}

;; 通过函数创建集合
(hash-set 1 1 2 2)
;; 向集合里面增加一个已经存在的值是加不进去的
(conj #{:a :b} :b)

(hash-set [1 1 2 3] [2 2 45])

(doc set)
;; 从向量创建集合
(set [3 3 3 4 4])

;; 从字符串创建集合
(set "hello")

;; 从list创建集合
(set '(1 1 3 3))

;; 从map创建集合，每一对组成一个新的元素
(set {1 1 2 3})

;; 不过这个貌似就不成功
;; (set {1 2 1 3 4 5})

;; 可以从上面的例子看出，set其实所做的动作就是分解后面的数据结构，变成单个元素，然后放入集合


#{1 {1 2}}
#{ 1 [1]}
#{1 '(1)}
#{1 #{1}}

;; 查看某个集合中是否存在某个元素
(contains? #{:a :b} :a)
(contains? #{:a :b} :c)
(contains? #{:a :b} 3)
(contains? #{nil} nil)

;; 通过关键字对集合进行操作
(:a #{:a :b} "bb")
(:d #{:a :b} "bb")

(get #{:a :b} :a)
(get #{:a :b} "kurt vonnegut")

;; 如果不存在，返回一个默认的返回值
(get #{:a :b} "kurt vonnegut" "hhhh")

;; 通过get来判断一个集合里面是否有nil是不行的
;; 要通过contains?来判断
(get #{:a nil} nil)
;; => true
(contains? #{:a nil} nil)
